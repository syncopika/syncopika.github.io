{
    "filename": "11-24-21",
    "title": "taking a closer look at asynchronous JavaScript",
    "date": "11/24/21",
    "tags": [
        "programming",
        "javascript"
    ],
    "content": "<p>Recently I thought about async/await in JavaScript and I (again) got confused how using await differed from just regular synchronous, blocking code.\n</p><p>From what I understand, await itself does block, but just the function it's running in (I think <b><a href=\"https://softwareengineering.stackexchange.com/questions/183576/asyncawait-sync\">this post</a></b> is fairly helpful); it does not necessarily prevent other code from running asynchronously because whatever await is waiting for could be running asynchronous code inside itself.\n</p><p>I also happened upon <a href=\"https://rclayton.silvrback.com/avoid-synchronous-functions-in-node-js\">this blog post</a> by Richard Clayton and was inspired to compare the performance of doing things synchronously vs asynchronously.\n</p><h3>experiment:\n</h3><p>Let's have a look at this code snippet, for example, with Node.js:\n</p><pre><code>const fs = require(\"fs\");\nconst util = require(\"util\");\n\nasync function main(){\n    // reading files synchronously\n    const start = Date.now();\n    const file1 = fs.readFileSync(\"test.txt\");\n    const file2 = fs.readFileSync(\"test2.txt\");\n    const end = Date.now();\n    console.log(\"start: \" + start);\n    console.log(\"end: \" + end);\n    \n    console.log(\"-------------------------\");\n    \n    // now reading files \"synchronously\" using await\n    // note that fs.readFile needs to be promisified\n    // so it will return a Promise\n    const readFile = util.promisify(fs.readFile);\n    const start2 = Date.now();\n    const f1 = await readFile(\"test.txt\");\n    const f2 = await readFile(\"test2.txt\");\n    const end2 = Date.now();\n    console.log(\"start: \" + start2);\n    console.log(\"end: \" + end2);\n    \n    console.log(\"-------------------------\");\n    // gathering up the results of a bunch of async tasks\n    // I think highlights a use case for needing async functionality,\n    // even though a lot of examples out there demo async/await\n    // in a synchronous process (e.g. just await on one thing)\n    // in this way we allow the reading of multiple files to\n    // happen asynchronously (so concurrently, but not parallel), \n    // which should allow a performance advantage\n    // over synchronously (especially with a large enough numbers of files)\n    const start3 = Date.now();\n    const res = await Promise.all([readFile(\"test.txt\"), readFile(\"test2.txt\")]);\n    const end3 = Date.now();\n    console.log(\"start: \" + start3);\n    console.log(\"end: \" + end3);\n}\n\nmain();\n\n</code></pre><p>text.txt and text2.txt aren't large files at all and they just have a line of text in each of them.\n</p><p>Below are my results in 5 consecutive runs:\n</p><pre><code>// run 1\nstart: 1638057607490\nend: 1638057607509\n-------------------------\nstart: 1638057607532\nend: 1638057607543\n-------------------------\nstart: 1638057607545\nend: 1638057607560\n\n// run 2\nstart: 1638057609003\nend: 1638057609003\n-------------------------\nstart: 1638057609012\nend: 1638057609019\n-------------------------\nstart: 1638057609021\nend: 1638057609022\n\n// run 3\nstart: 1638057610310\nend: 1638057610310\n-------------------------\nstart: 1638057610319\nend: 1638057610325\n-------------------------\nstart: 1638057610327\nend: 1638057610328\n\n// run 4\nstart: 1638057724608\nend: 1638057724608\n-------------------------\nstart: 1638057724617\nend: 1638057724623\n-------------------------\nstart: 1638057724624\nend: 1638057724626\n\n// run 5\nstart: 1638057728654\nend: 1638057728655\n-------------------------\nstart: 1638057728664\nend: 1638057728669\n-------------------------\nstart: 1638057728671\nend: 1638057728672\n\n</code></pre><p>note: I think the very first run took an unusually long time for each task because it was the first time running the program in a while (although I don't know the exact cause for why that is).\n</p><h3>results:\n</h3><p>From this little experiment we can see it took, on average, 4ms for the synchronous way, 7ms for using await in a synchronous manner, and 4ms for using await but letting the read operation for each file run asynchronously.\n</p><p>Overall I think the results make sense - using await in a synchronous manner (the 2nd task) took longer than letting readFile run asynchronously for each file and then awaiting the completion of reading all the files (the 3rd task); in the latter scenario, all the files can be sort of worked on at the \"same\" time, whereas in the former each file needs to be read to completion before the next one can be started. The 1st task, where readFileSync is used, seemed pretty fast. I would guess this seemingly fast performance may be because my sample size is so small with just 2 files (which would be consistent with Richard Clayton's experience).\n</p><p>For an even better comparison of async vs sync on performance, it would be interesting to try this experiment on different numbers of files and variable-sized files!\n</p><p>The code snippet and test files are <b><a href=\"https://github.com/syncopika/syncopika.github.io/tree/newstuff/blog_entries/content\">here</a></b> to play with. \n</p><p>If any technical, spelling or grammatical errors are present, please feel free to let me know via an issue at <b><a href=\"https://github.com/syncopika/syncopika.github.io\">this repo</a></b>.\n</p><p>Thanks for reading!</p>"
}