<!doctype html>

<html>

<head>
  <title> QR code generator (WIP) </title>
  
  <style>
    body {
      text-align: center;
    }
    
    canvas {
      display: block;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
  </style>
</head>

<body>
  <h1> QR code generator (WIP) </h1>
  <p> hi, nothing to see here yet :) </p>
  <input type='text' />
  <button onclick="init()"> generate </button>
</body>

<script>
// https://www.thonky.com/qr-code-tutorial/introduction
// https://www.qrcode.com/en/about/version.html

// tables

// https://www.thonky.com/qr-code-tutorial/character-capacities
// map QR version to error correction level + max char capacity
const characterCapacities = {
  1: {
    "L": 17, // only assuming byte mode atm
    "M": 14,
    "Q": 11,
    "H": 7,
  },
  2: {
    "L": 32,
    "M": 26,
    "Q": 20,
    "H": 14,
  },
  3: {
    "L": 53,
    "M": 42,
    "Q": 32,
    "H": 24,
  },
  4: {
    "L": 78,
    "M": 62,
    "Q": 46,
    "H": 34,
  },
  5: {
    "L": 106,
    "M": 84,
    "Q": 60,
    "H": 44,
  },
  6: {
    "L": 134,
    "M": 106,
    "Q": 74,
    "H": 58,
  },
  7: {
    "L": 154,
    "M": 122,
    "Q": 86,
    "H": 64,
  },
  8: {
    "L": 192,
    "M": 152,
    "Q": 108,
    "H": 84,
  },
  9: {
    "L": 230,
    "M": 180,
    "Q": 130,
    "H": 98,
  },
  10: {
    "L": 271,
    "M": 213,
    "Q": 151,
    "H": 119,
  },
  11: {
    "L": 321,
    "M": 251,
    "Q": 177,
    "H": 137,
  },
  12: {
    "L": 367,
    "M": 287,
    "Q": 203,
    "H": 155,
  },
  13: {
    "L": 425,
    "M": 331,
    "Q": 241,
    "H": 177,
  },
  14: {
    "L": 458,
    "M": 362,
    "Q": 258,
    "H": 194,
  },
  15: {
    "L": 520,
    "M": 412,
    "Q": 292,
    "H": 220,
  },
  16: {
    "L": 586,
    "M": 450,
    "Q": 322,
    "H": 250,
  },
  17: {
    "L": 644,
    "M": 504,
    "Q": 364,
    "H": 280,
  },
  18: {
    "L": 718,
    "M": 560,
    "Q": 394,
    "H": 310,
  },
  19: {
    "L": 792,
    "M": 624,
    "Q": 442,
    "H": 338,
  },
  20: {
    "L": 858,
    "M": 666,
    "Q": 482,
    "H": 382,
  },
  21: {
    "L": 929,
    "M": 711,
    "Q": 509,
    "H": 403,
  },
  22: {
    "L": 1003,
    "M": 779,
    "Q": 565,
    "H": 439,
  },
  23: {
    "L": 1091,
    "M": 857,
    "Q": 611,
    "H": 461,
  },
  24: {
    "L": 1171,
    "M": 911,
    "Q": 661,
    "H": 511,
  },
  25: {
    "L": 1273,
    "M": 997,
    "Q": 715,
    "H": 535,
  },
  26: {
    "L": 1367,
    "M": 1059,
    "Q": 751,
    "H": 593,
  },
  27: {
    "L": 1465,
    "M": 1125,
    "Q": 805,
    "H": 625,
  },
  28: {
    "L": 1528,
    "M": 1190,
    "Q": 868,
    "H": 658,
  },
  29: {
    "L": 1628,
    "M": 1264,
    "Q": 908,
    "H": 698,
  },
  30: {
    "L": 1732,
    "M": 1370,
    "Q": 982,
    "H": 742,
  },
  31: {
    "L": 1840,
    "M": 1452,
    "Q": 1030,
    "H": 790,
  },
  32: {
    "L": 1952,
    "M": 1538,
    "Q": 112,
    "H": 842,
  },
  33: {
    "L": 2068,
    "M": 1628,
    "Q": 1168,
    "H": 898,
  },
  34: {
    "L": 2188,
    "M": 1722,
    "Q": 1228,
    "H": 958,
  },
  35: {
    "L": 2303,
    "M": 1809,
    "Q": 1283,
    "H": 983,
  },
  36: {
    "L": 2431,
    "M": 1911,
    "Q": 1351,
    "H": 1051,
  },
  37: {
    "L": 2563,
    "M": 1989,
    "Q": 1423,
    "H": 1093,
  },
  38: {
    "L": 2699,
    "M": 2099,
    "Q": 1499,
    "H": 1139,
  },
  39: {
    "L": 2809,
    "M": 2213,
    "Q": 1579,
    "H": 1219,
  },
  40: {
    "L": 2953,
    "M": 2331,
    "Q": 1663,
    "H": 1273,
  },
};

// TODO: add error correction table
// atm we only care about level M for error correction
const errorCorrectionTable = {
  "1M": {
    "totalDataCodewords": 16,
    "ecCodewordsPerBlock": 10,
    "numBlocksGroup1": 1,
    "numDataCodewordsPerGroup1Block": 16,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "2M": {
    "totalDataCodewords": 28,
    "ecCodewordsPerBlock": 16,
    "numBlocksGroup1": 1,
    "numDataCodewordsPerGroup1Block": 28,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "3M": {
    "totalDataCodewords": 44,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 1,
    "numDataCodewordsPerGroup1Block": 44,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "4M": {
    "totalDataCodewords": 64,
    "ecCodewordsPerBlock": 18,
    "numBlocksGroup1": 2,
    "numDataCodewordsPerGroup1Block": 32,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "5M": {
    "totalDataCodewords": 86,
    "ecCodewordsPerBlock": 24,
    "numBlocksGroup1": 2,
    "numDataCodewordsPerGroup1Block": 43,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "6M": {
    "totalDataCodewords": 108,
    "ecCodewordsPerBlock": 16,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 27,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "7M": {
    "totalDataCodewords": 124,
    "ecCodewordsPerBlock": 18,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 31,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "8M": {
    "totalDataCodewords": 154,
    "ecCodewordsPerBlock": 22,
    "numBlocksGroup1": 2,
    "numDataCodewordsPerGroup1Block": 38,
    "numBlocksGroup2": 2,
    "numDataCodewordsPerGroup2Block": 39,
  },
  "9M": {
    "totalDataCodewords": 182,
    "ecCodewordsPerBlock": 22,
    "numBlocksGroup1": 3,
    "numDataCodewordsPerGroup1Block": 36,
    "numBlocksGroup2": 2,
    "numDataCodewordsPerGroup2Block": 37,
  },
  "10M": {
    "totalDataCodewords": 216,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 43,
    "numBlocksGroup2": 1,
    "numDataCodewordsPerGroup2Block": 44,
  },
  "11M": {
    "totalDataCodewords": 254,
    "ecCodewordsPerBlock": 30,
    "numBlocksGroup1": 1,
    "numDataCodewordsPerGroup1Block": 50,
    "numBlocksGroup2": 4,
    "numDataCodewordsPerGroup2Block": 51,
  },
  "12M": {
    "totalDataCodewords": 290,
    "ecCodewordsPerBlock": 22,
    "numBlocksGroup1": 6,
    "numDataCodewordsPerGroup1Block": 36,
    "numBlocksGroup2": 2,
    "numDataCodewordsPerGroup2Block": 37,
  },
  "13M": {
    "totalDataCodewords": 334,
    "ecCodewordsPerBlock": 22,
    "numBlocksGroup1": 8,
    "numDataCodewordsPerGroup1Block": 37,
    "numBlocksGroup2": 1,
    "numDataCodewordsPerGroup2Block": 38,
  },
  "14M": {
    "totalDataCodewords": 365,
    "ecCodewordsPerBlock": 24,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 40,
    "numBlocksGroup2": 5,
    "numDataCodewordsPerGroup2Block": 41,
  },
  "15M": {
    "totalDataCodewords": 415,
    "ecCodewordsPerBlock": 24,
    "numBlocksGroup1": 5,
    "numDataCodewordsPerGroup1Block": 41,
    "numBlocksGroup2": 5,
    "numDataCodewordsPerGroup2Block": 42,
  },
  "16M": {
    "totalDataCodewords": 453,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 7,
    "numDataCodewordsPerGroup1Block": 45,
    "numBlocksGroup2": 3,
    "numDataCodewordsPerGroup2Block": 46,
  },
  "17M": {
    "totalDataCodewords": 507,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 10,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 1,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "18M": {
    "totalDataCodewords": 563,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 9,
    "numDataCodewordsPerGroup1Block": 43,
    "numBlocksGroup2": 4,
    "numDataCodewordsPerGroup2Block": 44,
  },
  "19M": {
    "totalDataCodewords": 627,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 3,
    "numDataCodewordsPerGroup1Block": 44,
    "numBlocksGroup2": 11,
    "numDataCodewordsPerGroup2Block": 45,
  },
  "20M": {
    "totalDataCodewords": 669,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 3,
    "numDataCodewordsPerGroup1Block": 41,
    "numBlocksGroup2": 13,
    "numDataCodewordsPerGroup2Block": 42,
  },
  "21M": {
    "totalDataCodewords": 714,
    "ecCodewordsPerBlock": 26,
    "numBlocksGroup1": 17,
    "numDataCodewordsPerGroup1Block": 42,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "22M": {
    "totalDataCodewords": 782,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 17,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 0,
    "numDataCodewordsPerGroup2Block": 0,
  },
  "23M": {
    "totalDataCodewords": 860,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 14,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "24M": {
    "totalDataCodewords": 860,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 4,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 14,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "25M": {
    "totalDataCodewords": 1000,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 8,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 13,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "26M": {
    "totalDataCodewords": 1062,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 19,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 4,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "27M": {
    "totalDataCodewords": 1128,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 22,
    "numDataCodewordsPerGroup1Block": 45,
    "numBlocksGroup2": 3,
    "numDataCodewordsPerGroup2Block": 46,
  },
  "28M": {
    "totalDataCodewords": 1193,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 3,
    "numDataCodewordsPerGroup1Block": 45,
    "numBlocksGroup2": 23,
    "numDataCodewordsPerGroup2Block": 46,
  },
  "29M": {
    "totalDataCodewords": 1267,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 21,
    "numDataCodewordsPerGroup1Block": 45,
    "numBlocksGroup2": 7,
    "numDataCodewordsPerGroup2Block": 46,
  },
  "30M": {
    "totalDataCodewords": 1373,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 19,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 10,
    "numDataCodewordsPerGroup2Block": 116,
  },
  "31M": {
    "totalDataCodewords": 1455,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 2,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 29,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "32M": {
    "totalDataCodewords": 1541,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 10,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 23,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "33M": {
    "totalDataCodewords": 1631,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 14,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 21,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "34M": {
    "totalDataCodewords": 1725,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 14,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 23,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "35M": {
    "totalDataCodewords": 1812,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 12,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 26,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "36M": {
    "totalDataCodewords": 1914,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 6,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 34,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "37M": {
    "totalDataCodewords": 1992,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 29,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 14,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "38M": {
    "totalDataCodewords": 2102,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 13,
    "numDataCodewordsPerGroup1Block": 46,
    "numBlocksGroup2": 32,
    "numDataCodewordsPerGroup2Block": 47,
  },
  "39M": {
    "totalDataCodewords": 2216,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 40,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 7,
    "numDataCodewordsPerGroup2Block": 48,
  },
  "40M": {
    "totalDataCodewords": 2334,
    "ecCodewordsPerBlock": 28,
    "numBlocksGroup1": 18,
    "numDataCodewordsPerGroup1Block": 47,
    "numBlocksGroup2": 31,
    "numDataCodewordsPerGroup2Block": 48,
  }
};

// note: only caring about byte mode atm
const versionCharCountIndicatorSizeMap = {
  1: 8, // version 1-9 -> 8 bits for representing the character count
  10: 16, // versions 10 - 26 -> 16 bits
  27: 16, // versions 27 - 40 -> 16 bits
};

function getCharCountIndicatorSize(version){
  const keys = Array.from(Object.keys(versionCharCountIndicatorSizeMap)).reverse();
  for(let k of keys){
    if(version >= k){
      return versionCharCountIndicatorSizeMap[k]; // e.g. if version is 20, we should get back 16
    }
  }
  return null;
}

function getInputStrAsBinaryStr(inputStr){
  // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/encode
  // convert the input to 8-bit ints per TextEncoder.encode
  const textEncoder = new TextEncoder();
  
  // .encode() returns a unint8 array, but we want to run map() on it to convert the ints to binary, so convert the result to a generic array
  const encodedStrArray = Array.from(textEncoder.encode(inputStr));
  
  // convert each 8-bit int to binary
  const res = encodedStrArray.map((i) => {
    // convert to binary
    const binStr = intToBinary(i);
    
    // pad as needed to match a length of 8
    const paddingAmount = 8 - binStr.length;
    //console.log(`int: ${i}, bin: ${binStr}`);
    return zeroPadLeftStr(binStr, paddingAmount);
  });
  
  // concat each binary
  return res.join(" "); // TODO: should there be a space?
}

function intToBinary(n){
  // TODO: need to pad up to certain num of bits based on version
  const binStr = [];
  
  while(n > 0){
    const rem = n % 2;
    binStr.unshift(rem);
    n = Math.floor(n / 2);
  }
  
  return binStr.join("");
}

function binaryToInt(binStr){
  let result = 0;
  let currMultiplier = 1;
  let idx = binStr.length - 1;
  while(idx > -1){
    if(binStr[idx] === '1'){
      result += currMultiplier;
    }
    currMultiplier *= 2;
    idx--;
  }
  return result;
}

function init(){
  // create the canvas to draw the QR code in
  const canvas = document.createElement('canvas'); 
  const ctx = canvas.getContext('2d');
  
  // set bg to black
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // let's default to "byte mode" for now (that is, only support strings with characters from ISO-8859-1 character set)
  const mode = '0100'; // mode indicator (4 bits)
  
  // let's default to level M for error correction (L - 7% data recovery, M - 15%, Q - 25%, H - 30%)
  // the higher the error correction level, the larger the QR code will be (b/c it takes more bytes)
  const errorCorrectionLevel = 'M';
  
  // figure out QR code version/size
  const qrVersion = getSmallestQRVersion("TODO: pass input string here", errorCorrectionLevel);
  
  // TODO: how do we know how big the canvas should be?
  // size of a QR code can be calculated with ((V - 1) * 4) + 21
  // where V is the QR code version
  
  // get character count indicator
  const charCountIndicator = getCharacterCountIndicator("TODO: pass input string here", qrVersion);
  
  // put charCountIndicator after mode
  
  // now encode the data into binary
  let encodedData = getInputStrAsBinaryStr("TODO: pass input string here");
  
  // put encodedData after charCountIndicator
  
  // determine required number of bits for this QR code
  const errorCorrection = errorCorrectionTable[`${qrVersion}M`];
  const totalDataCodewords = errorCorrection.totalDataCodewords;
  const totalBitsRequired = totalDataCodewords * 8;
  
  // add terminator bits (of 0) if needed
  if(encodedData.length + 4 < totalBitsRequired - 4){
    // if diff is greater than 4, add 4 0's max
    encodedData += '0000';
  } else if(encodedData.length + 4 >= totalBitsRequired){
    // add remaining 0s if diff < 4
    let diff = totalBitsRequired - encodedData.length;
    while(diff > 0){
      encodedData += '0';
      diff--;
    }
  }
  
  // add pad bytes if encoded data is still too short (e.g. a lot less than totalBitsRequired)
  const bitsToPad = totalBitsRequired - encodedData.length;
  let padBytesToAdd = bitsToAdd / 8;
  let count = 0;
  while(padBytesToAdd > 0){
    if(count % 2 === 0){
      // if count is even
      encodedData += '11101100';
    }else{
      // if count is odd
      encodedData += '00010001';
    }
    count++;
    padBytesToAdd--;
  }
  
  drawFinderPatterns(ctx, canvas.width, canvas.height);
  
  document.body.appendChild(canvas);
}

// TODO: needs tests
function getSmallestQRVersion(inputString, errorCorrectionLevel){
  // https://stackoverflow.com/questions/2219526/how-many-bytes-in-a-javascript-string
  
  // get num bytes of inputString
  const numBytesInput = (new Blob([inputString])).size;
  
  // check table for version
  const versions = Array.from(Object.keys(characterCapacities));
  versions.sort();
  for(let i = versions.length - 1; i >= 0; i--){
    const v = versions[i];
    if(characterCapacities[v][errorCorrectionLevel] >= numBytesInput){
      return v;
    }
  }
  
  return null;
}

function getCharacterCountIndicator(inputString, qrVersion){
  const numChars = inputString.length;
  
  // convert numChars to binary string
  let numCharsBinStr = intToBinary(numChars);
  
  // pad as needed depending on QR version
  const expectedLen = getCharCountIndicatorSize(qrVersion);
  const padLen = expectedLen - numCharsBinStr.length;
  
  // TODO: use zeroPadLeftStr function below
  if(padLen > 0){
    let zeroPadding = "";
    for(let i = 0; i < padLen; i++){
      zeroPadding += "0";
    }
    numCharsBinStr = zeroPadding + numCharsBinStr;
  }
  
  return numCharsBinStr;
}

function zeroPadLeftStr(inputStr, paddingAmount){
  if(paddingAmount > 0){
    let zeroPadding = "";
    for(let i = 0; i < paddingAmount; i++){
      zeroPadding += "0";
    }
    return zeroPadding + inputStr;
  }
  return inputStr;
}

function drawFinderPatterns(ctx, width, height){
  // finder patterns are always 7 x 7
  // with an inner white square of 5 x 5
  // and a solid black square in the center that's 3 x 3
  // finder patterns are also always surrounded by a separator, which is just a white line
  const separatorDim = 8;
  const finderOuterDim = 7;
  const finderInnerDim = 5;
  const finderInnerCenter = 3;
  
  // draw top-right corner pattern
  ctx.fillStyle = 'rgb(255,255,255)'; // draw separator first
  ctx.fillRect(width - finderOuterDim - 1, 0, separatorDim, separatorDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(width - finderOuterDim, 0, finderOuterDim, finderOuterDim);
  
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.fillRect(width - finderOuterDim + 1, 1, finderInnerDim, finderInnerDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(width - finderOuterDim + 2, 2, finderInnerCenter, finderInnerCenter);
  
  // draw top-left corner pattern
  ctx.fillStyle = 'rgb(255,255,255)'; // draw separator first
  ctx.fillRect(0, 0, separatorDim, separatorDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(0, 0, finderOuterDim, finderOuterDim);
  
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.fillRect(1, 1, finderInnerDim, finderInnerDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(2, 2, finderInnerCenter, finderInnerCenter);
  
  // draw bottom-left corner pattern
  ctx.fillStyle = 'rgb(255,255,255)'; // draw separator first
  ctx.fillRect(0, height - finderOuterDim - 1, separatorDim, separatorDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(0, height - finderOuterDim, finderOuterDim, finderOuterDim);
  
  ctx.fillStyle = 'rgb(255,255,255)';
  ctx.fillRect(1, height - finderOuterDim + 1, finderInnerDim, finderInnerDim);
  
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(2, height - finderOuterDim + 2, finderInnerCenter, finderInnerCenter);  
}

function addAlignmentPatterns(){
  // TODO
  // QR codes that are >= version 2 are required to have alignment patterns
  // an alignment pattern is a 5 x 5 black square with a 3 x 3 white square inside and a black squar e in the center
}

function addTimingPatterns(){
  // TODO
}

function addDarkModuleAndReservedAreas(){
  // TODO
}

function addData(){
  // TODO
}


function test(){
  // TODO
  // assumptions: level M for error correction, byte mode only
  const mode = "0100";
  console.log(`mode: ${binaryToInt(mode)}`);
  const errorCorrectionLevel = "M";
  const input = "http://www.google.com";
  
  const qrVersion = getSmallestQRVersion(input, errorCorrectionLevel);
  console.log(`QR version: ${qrVersion}`);
  // assertion for qrVersion
  
  const charCountIndicator = getCharacterCountIndicator(input, qrVersion);
  console.log(`character count indicator: ${charCountIndicator}`);
  // assertion for charCountIndicator
  
  const encodedInputStr = getInputStrAsBinaryStr(input);
  console.log(`encoded input str: ${encodedInputStr}`);
  // assertion for encodedInputStr
}

test();

</script>


</html>